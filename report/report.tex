\documentclass[oribibl]{llncs}
 
\usepackage{amssymb} % AMS Fonts
\usepackage{amsmath} % AMSLaTeX
\usepackage{url}

\newcommand{\ZZ}{{\mathbb{Z}}}
\newcommand{\QQ}{{\mathbb{Q}}}
\newcommand{\RR}{{\mathbb{R}}}
\newcommand{\CC}{{\mathbb{C}}}
\newcommand{\NN}{{\mathbb{N}}}
\renewcommand{\H}{{\mathcal{H}}}
\renewcommand{\L}{{\mathcal{L}}}
\newcommand{\F}{{\mathsf{F}}}
\newcommand{\bigO}{{\mathsf{O}}}
\newcommand{\R}{{\mathsf{R}}}
\newcommand{\Fp}{{\mathbb{F}_p}}
\newcommand{\Fq}{{\mathbb{F}_q}}
\newcommand{\Fqd}{{\mathbb{F}_{q^d}}}
\newcommand{\Fqe}{{\mathbb{F}_{q^e}}}
\newcommand{\Fz}{{\F[z]}}
\newcommand{\Fzf}{{\Fz /(f)}}
\newcommand{\Fzfe}{{\Fz /(f^e)}}
\newcommand{\Rn}{{\R^{n \times 1}}}
\newcommand{\Rnn}{{\R^{n \times n}}}
\newcommand{\Fden}{{\F^{den \times 1}}}
\newcommand{\Fdenden}{{\F^{den \times den}}}
\newcommand{\ZZp}{{\ZZ_p}}
\newcommand{\ZZpe}{{\ZZ_{p^e}}}
\newcommand{\nxn}{{n\times n}}
\newcommand{\calI}{{\mathcal I}}

\newcommand{\FD}{{\F[\partial;\sigma,\delta]}}
\newcommand{\D}{{\partial}}
\newcommand{\shift}{{\mathcal{S}}}
\newcommand{\diff}{{\lower3pt\hbox{\large$'$}}}
\renewcommand{\k}{{\mathsf{k}}}
\newcommand{\lclm}{{\mbox{\upshape lclm}}}
\newcommand{\lcrm}{{\mbox{\upshape lcrm}}}
\newcommand{\gcld}{{\mbox{\upshape gcld}}}
\newcommand{\gcrd}{{\mbox{\upshape GCRD}}}



\newcommand{\smallskipback}{\vspace{-\smallskipamount}}
\newcommand{\medskipback}{\vspace{-\medskipamount}}
\newcommand{\bigskipback}{\vspace{-\bigskipamount}}



%\reversemarginpar
\makeatletter
\@twosidefalse
\makeatother
%\renewcommand*{\marginfont}{\color{red}\bf}
%\newcommand{\TODO}[1]{\marginnote[#1]{}}

\bibliographystyle{alpha}

\begin{document}

\title{\textsc{CREST-Z3} - Automated Test Generation Capable of Nonlinear Constraints\\[12pt]
Project for CS847}

\author{X. Lan, M. Wexler, A. Heinle}

\institute{University of Waterloo, David R. Cheriton School of Computer Science}

\maketitle

\begin{abstract}
  In this project we will explore \textsc{CREST-Z3} \cite{CRESTZ3}, an automated test case generator for C-programs. It is an extension of the tool \textsc{CREST} \cite{CREST} capable of solving nonlinear constraints in the process of generating tests. We will discuss the capabilities and the practical, as well as the theoretical limitations of this tool.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
%Here: Description of the problem they want to solve
%         Reference to discussed DART
%         Examples where this can appear.
%         Outline of the report

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{CREST}
%Here: How to use CREST
%         Software architecture of CREST
%         Examples

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{\textsc{Z3}}

\subsection{Introduction to Z3}
The tool \textsc{Z3} \cite{de2008z3}  is developed by researchers from \textsc{Microsoft} to decide -- if
possible -- ``Satisfiability modulo theories'' (abbreviated SMT)
problems. These problems are given in first order logic and can be
seen as an extension to the satisfiability problem in predicate logic
(SAT) by introducing datatypes like numbers and their respective
operations. A standard to represent those formulas in a automatically
readable form was developed in the \textsc{SMT-LIB} project  \cite{barrett2010smt}.
The developers of \textsc{Z3} are using this standard as their
internal representation.

We will refrain from providing a detailed description of SMT problems
and their representation as this would exceed the scope of this
report. But the following example will present the basic structure of
those problems.

\begin{example}
  Given the variables $x,y,z$, which we consider to have the type to
  be integer numbers. An SMT solver could answer the question whether
  a solution for $x,y$ and $z$ does exist given the following
  constraints:
  \begin{enumerate}
    \item $x \neq y$
    \item $xy+x^2y=z$
    \item $|z|<10$.
  \end{enumerate}
  The solver would either state that he cannot solve this problem, or
  no solution does exist (provable), or it would provide values for
  $x,y$ and $z$ satisfying the given conditions.
\end{example}

\textsc{Z3} can be included as a library to C/++ source code and one
can call the theorem prover from there. This is very handy as one does
not have to parse an input to a tool and parse the output back, but
just can call the respective functions inside his/her own functions.

The source code of \textsc{Z3} was recently (September 2012) published
by Microsoft (\url{http://z3.codeplex.com/}), so we could examine the
techniques the developers used to handle the nonlinear equations we
are looking for inside their code. We will go into more detail on that
after we discussed some theory behind nonlinear equations.

\subsection{Theoretical Limitations}

There are some theoretical limitations given considering the problem
of solving nonlinear equations.

Given the following scenario: consider integer variables $x_1, \ldots,
x_n, n \in \NN$, and a boolean expression inside an if statement that
evaluates to true if and only if a polynomial given in those variables
is zero for some choice of $x_1, \ldots, x_n$. Finding a solution for
the $x_i$ is the so called Hilbert's 10th problem
\cite{davis1984hilbert}, which was proven to be undecidable
\cite{matiyasevich1970enumerable}.

Nonetheless, one can always try to find solutions and cancel the
computations after a certain amount of time.

Given a set of polynomial equations, the status quo to find solutions
is to calculate a so called Gr\"obner basis of this system (originated
in \cite{buchberger1970algorithmisches}). This can be seen as a
simplification of the system, which leads in the case of the existence
of only finitely many solutions directly to the solutions. Inside the
source code of \textsc{Z3} we could also find an implementation an
algorithm to calculate those bases.

But there is one problem to this approach. Calculating a Gr\"obner
basis has double exponential complexity, independent from the choice
of the algorithm to compute it (\cite{mayr1982complexity}). Therefore,
computations can take a long time and the output may be the most
simple one, but is still hard to utilize for finding the
solutions.

Finding solutions to nonlinear equations is also heavily studied in current
research. Almost every computer algebra system provides a
functionality to solve systems of equations, but there are still
plenty of examples where those solvers do fail. Thus one is also
limited by the possibilities current research provides.

\subsection{Practically Hard Problems}

In order to illustrate where one reaches those limitations, we
considered the following code:

\begin{verbatim}
int main(int argc, char *argv[])
{
  int w;
  int x;
  int y;
  int z;
  if (x*x*y*y*y*z*z == 2700){
    if (x*x*y*w + y*y*w*w == 525){
      if ( x * y*w+y*y*y*w*w==1365){
        printf("GOAL %d %d %d %d\n", x, y, z, w);
          return 1;
        }
     }
  }
  return 0;
}
\end{verbatim}

In order to cover all branches, one could use as input $(x,y,z,w) :=
(2,3,5,7)$. \textsc{Z3} is not able to solve it. We stopped the
calculation after a couple of hours.

Let us study the reason why it fails. \textsc{Z3} will try to compute
a Gr\"obner basis of the ideal generated by
\begin{eqnarray*}
  x^2y^3z^2 - 2700, \quad x^2yw + y^2w^2 - 525, \quad xyw + y^3w^2,
\end{eqnarray*}
and based on that result, it will try to solve the equation. As said,
solving for integer values is in general undecidable.

Let us look at the Gr\"obner basis for this system, which we
calculated using the computer algebra system \textsc{Singular}
\cite{Singular:2012}. The output is a polynomial system that fits into
a file of the size of 283KB. We will give a short snapshot of one
element in the output for visualization:

\begin{verbatim}
6755988021120000yw31-165994625678918400000yw30
+1737133233041462256000000yw29
-10103309530871289445440000000yw28
+35744012480436414061798800000000yw27
-79140476520758021570218836000000000yw26
+108725930332567845122270489310000000000yw25
-88760995051809423012610038134400000000000yw24
+39085314130645312603256453079810000000000000yw23
-7116024938996671115986413518424570000000000000yw22
+[...]
\end{verbatim}

\textsc{Singular} is specialized in performing those computations, and
it took several minutes to compute this Gr\"obner basis. There are
several factors that play a role how fast an algorithm computes this
Gr\"obner basis. One of them is how ``smart'' it is implemented. This
computation can take hours if the algorithm is not smart.

Of course, one can also try to solve those equation using
state-of-the-art computer algebra systems. We observed that those will
not provide the easy solution that we know about this system.

The computer algebra system \textsc{Maple} (\cite{Maple}) e.g. outputs the following:
\begin{verbatim}
{w = w,
x = RootOf(13*w*_Z^6-5*w*_Z^5+13*w^2*_Z^3+(-5*w^2+20475*w)
    *_Z^2-5250*w*_Z-1378125+17745*w^2),
y = -(13*RootOf(13*w*_Z^6-5*w*_Z^5+13*w^2*_Z^3
    +(-5*w^2+20475*w)*_Z^2-5250*w*_Z-1378125+17745*w^2)^2*w[...],
z = 338*RootOf(-15138703125*w^6+61992127968750*w^5
    -12932841796875*w^4-4814544287109375*w^3[...]}
\end{verbatim}

This means that \textsc{Maple} recognizes that the value of $w$ can be
chosen arbitrarily and that the solution solely depends on the values
of $x,y$ and $z$. Furthermore does the solution of \textsc{Maple}
depend on algebraic extensions of the ground field (usually chosen to
be $\QQ$).

The computer algebra system \textsc{Sage} (\cite{sage}), which utilizes
\textsc{Maxima} (\cite{maxima}) for solving such equations, failed to
output any solution.

The last computer algebra system that we tested for those purposes was
\textsc{Mathematica} \cite{wolfram1999mathematica} in the context of
\textsc{Wolfram Alpha}\\ (\url{http://www.wolframalpha.com}). It found
several solutions, but not one with integer values. One solution was
for example:
\begin{verbatim}
w<-(25 sqrt(21))/13 and 
x = Root[13 #1^6 w-5 #1^5 w+13 #1^3 w^2+#1^2 (20475 w-5 w^2)-5250 #1
    w+17745 w^2-1378125&, 1]
and y = 1/2 (sqrt((x^4+2100)/w^2)-x^2/w)
and z = -30 sqrt(3) sqrt(1/(x^2 y^3))
\end{verbatim}

As a conclusion, one can see that deriving an integer solution using
those helps from outside appears to be a very hard task.

\subsection{Alternatives}

\textsc{Z3} is of course not the only \textsc{SMT}-solver that is
available, yet it belongs to the group of the most powerful
ones. Other tools that are capable of solving complex SMTs and that use the
same input as \textsc{Z3} are
\begin{itemize}
  \item \textsc{Alt-Ergo} (\cite{bobotalt}) and
  \item \textsc{CVC4} (\cite{barrett2011cvc4}).
\end{itemize}

In the original \textsc{CREST} project, \textsc{YICES} (\cite{dutertre2006yices}) was used for
solving. It was not capable of nonlinear constraints, but accepted
input in the SMT-LIB standard. Therefore, replacing the SMT-solver in
the \textsc{CREST} project took only the instrumentation effort, which
can also be done similarly with the tools above. This would lead to an
interesting comparison between those tools regarding the branches in
code they are able to resolve.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Experiments}

%Here: Real life C programs (instructed)
%         Outline how often we find really complicated examples in C-Code
%         Feasibility of instructing programs for CREST


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion and Future Work}

%Here: Extension to other programming languages? Or even Computer algebra systems?
%         Feasible for real world, as conditions do not get very complicated in general
%         Good for testing software that implements formulas or approximations.
%         Extending it to more general data-types?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliography{report}

\end{document}
