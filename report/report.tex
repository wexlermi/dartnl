\documentclass[oribibl]{llncs}
 
\usepackage{amssymb} % AMS Fonts
\usepackage{amsmath} % AMSLaTeX
\usepackage{url}

\newcommand{\ZZ}{{\mathbb{Z}}}
\newcommand{\QQ}{{\mathbb{Q}}}
\newcommand{\RR}{{\mathbb{R}}}
\newcommand{\CC}{{\mathbb{C}}}
\newcommand{\NN}{{\mathbb{N}}}
\renewcommand{\H}{{\mathcal{H}}}
\renewcommand{\L}{{\mathcal{L}}}
\newcommand{\F}{{\mathsf{F}}}
\newcommand{\bigO}{{\mathsf{O}}}
\newcommand{\R}{{\mathsf{R}}}
\newcommand{\Fp}{{\mathbb{F}_p}}
\newcommand{\Fq}{{\mathbb{F}_q}}
\newcommand{\Fqd}{{\mathbb{F}_{q^d}}}
\newcommand{\Fqe}{{\mathbb{F}_{q^e}}}
\newcommand{\Fz}{{\F[z]}}
\newcommand{\Fzf}{{\Fz /(f)}}
\newcommand{\Fzfe}{{\Fz /(f^e)}}
\newcommand{\Rn}{{\R^{n \times 1}}}
\newcommand{\Rnn}{{\R^{n \times n}}}
\newcommand{\Fden}{{\F^{den \times 1}}}
\newcommand{\Fdenden}{{\F^{den \times den}}}
\newcommand{\ZZp}{{\ZZ_p}}
\newcommand{\ZZpe}{{\ZZ_{p^e}}}
\newcommand{\nxn}{{n\times n}}
\newcommand{\calI}{{\mathcal I}}

\newcommand{\FD}{{\F[\partial;\sigma,\delta]}}
\newcommand{\D}{{\partial}}
\newcommand{\shift}{{\mathcal{S}}}
\newcommand{\diff}{{\lower3pt\hbox{\large$'$}}}
\renewcommand{\k}{{\mathsf{k}}}
\newcommand{\lclm}{{\mbox{\upshape lclm}}}
\newcommand{\lcrm}{{\mbox{\upshape lcrm}}}
\newcommand{\gcld}{{\mbox{\upshape gcld}}}
\newcommand{\gcrd}{{\mbox{\upshape GCRD}}}



\newcommand{\smallskipback}{\vspace{-\smallskipamount}}
\newcommand{\medskipback}{\vspace{-\medskipamount}}
\newcommand{\bigskipback}{\vspace{-\bigskipamount}}



%\reversemarginpar
\makeatletter
\@twosidefalse
\makeatother
%\renewcommand*{\marginfont}{\color{red}\bf}
%\newcommand{\TODO}[1]{\marginnote[#1]{}}

\bibliographystyle{alpha}

\begin{document}

\title{\textsc{CREST-Z3} - Automated Test Generation Capable of Nonlinear Constraints\\[12pt]
Project for CS846}

\author{X. Lan, M. Wexler, A. Heinle}

\institute{University of Waterloo, David R. Cheriton School of Computer Science}

\maketitle

\begin{abstract}
  In this project we will explore \textsc{CREST-Z3} \cite{CRESTZ3}, an automated test case generator for C-programs. It is an extension of the tool \textsc{CREST} \cite{CREST} capable of solving nonlinear constraints in the process of generating tests. We will discuss the capabilities and the practical, as well as the theoretical limitations of this tool.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

In the beginning of the course, there was a presentation given on the
paper \cite{godefroid2005dart}. The authors of this paper presented an
automated way of generating test sets for given programs written in
the programming language \textsc{C}. The main principle of that tool
appears in the literature as \textbf{Concolic Testing} (this terminology appeared
for the first time in the paper \cite{sen2005cute}).

Informally speaking, concolic testing refers the concrete
execution of the program given either random or specifically chosen
values for the variables. During this execution, one collects symbolic
conditions on the
variables in order to reach code lines whenever a branch occurs
(e.g. induced by an \texttt{if}-statement). Those conditions are fed
to a theorem prover in order to solve for possible variable values to
enter each branch. With that, people are trying to generate test sets
that satisfy the best coverage of the code -- in terms of nodes in the
control flow graph -- as possible.

\textsc{CREST}, in its original version, used a theorem prover called
\textsc{YICES} (\cite{dutertre2006yices}) for the part of solving
conditions to enter a branch. It is a powerful tool, yet it has a
significant weakness: It can only deal with linear equations. This is
a strong restriction, as for example an equation like
$$x^2 = 14 \mod 47$$
for $x \in \ZZ$ could not be resolved.
Also in other concolic testing tools like \textsc{CUTE}
(\cite{sen2005cute}), \textsc{DART},
\textsc{EXE} (\cite{cadar2008exe}) and \textsc{PathCrawler}
(\cite{williams2005pathcrawler}), only linear equations are solvable.

This is the case for a good reason, as we will see in section \ref{sctn:Z3} where we will discuss computational limitations we have
considering nonlinear equations.

Nevertheless, for the nonlinear case, in the project \textsc{CREST-Z3}, the theorem prover was replaced
by \textsc{Microsoft}s solution \textsc{Z3}
(\cite{de2008z3}), which can handle a broader range of equation types
including nonlinear equations. \textsc{CREST-Z3}, its architecture and
its practicality will be the subject of this paper.

The paper is organized as follows. Section \ref{sctn:CRESTZ3} is
dedicated to \textsc{CREST}(-\textsc{Z3}). We will see how one can use
this tool, specialities about its architecture, and some limitations
that we found.

In section \ref{sctn:Z3}, we will examine those limitations a little
bit closer from a theoretical point of view. A general overview of
\textsc{Z3} will also be provided.

Section \ref{sctn:Experiments} contains experiments we have done with
\textsc{CREST-Z3}. Furthermore, we were examining types of \textsc{C/++}-projects
where nonlinear equations do play a role in the branching conditions
of the code.

The last section draws a conclusion of our work. Furthermore, we will
provide possible ways how one can improve/extend the work to make it
either faster or more practically useful.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\textsc{CREST}(-\textsc{Z3})}
\label{sctn:CRESTZ3}

For notational convenience, we will from now on refer to
\textsc{CREST-Z3} as \textsc{CREST}. Most of the description of the
use of \textsc{CREST-Z3} can also be applied to the original
\textsc{CREST} project.

\subsection{How to use \textsc{CREST}}
We will start by presenting how one can use \textsc{CREST} to find
inputs in order to obtain a reasonable code coverage with its tests.

One has to manually instrument code prior of running \textsc{CREST}.

Let us study how this is done using the following example:

\begin{example}
\label{ex:codeForDemo}
\begin{verbatim}
[1]   #include <crest.h>
[2]   #include <stdio.h>
[3]  
[4]   int main(int argc, char *argv[])
[5]   {
[6]     int w;
[7]     int x;
[8]     int y;
[9]     int z;
[10]    CREST_int(x);
[11]    CREST_int(y);
[12]    CREST_int(z);
[13]    CREST_int(w);
[14]    if (x*y + z == 0){
[15]      w = x*y*z;
[16]      if (w == z + x*y-1){
[17]        printf("GOAL %d %d %d %d\n", x, y, z, w);
[18]        return 1;
[19]      }
[20]    }	
[21]    return 0;
[22]  }
\end{verbatim}
\end{example}

The main steps are:
\begin{enumerate}
  \item Including the \texttt{crest.h} header file of the
    \textsc{CREST} project (Line 1)
   \item For all variables that appear in branching nodes of the code
     (in this case the variables $x,y,z$ and $w$), one has to instruct
     \textsc{CREST} to collect symbolic conditions with respect to
     those variables during the
     execution. (Lines 10-13)
   \item OPTIONAL: Add a
     \texttt{printf} to every line inside conditional branch that
     outputs the variable values (Line 17). Then, during the execution of
     \textsc{CREST}, whenever a solution is found that enters the
     desired line of code (in this case line 18), an output is
     provided stating the calculated values for the variables.
\end{enumerate}

\begin{remark}
  This example already contains nonlinear constraints inside the
  \texttt{if}-statements and therefore serves as an example how
  \textsc{CREST-Z3} extends the functionality of the classical \textsc{CREST}.
\end{remark}

\begin{remark}
  The datatypes \textsc{CREST} can handle in the current status of the
  project are: (unsigned) characters, (unsigned) integers, (unsigned) shorts.
\end{remark}

Then, after compiling the \textsc{CREST} project according to the
instructions, one runs inside the \texttt{bin} folder of the project
the program \texttt{crestc} with the instructed file as input. This
will generate the control flow graph and will collect initial information
about the program. For this code analysis step, the developers of
\textsc{CREST} utilize a tool called \textsc{CIL} (\cite{necula2002cil}).

As a result, in the same folder as the instructed file, several other
files will appear, including the compiled version of the
program. Those files are provided by \textsc{CIL} and one can find the
control flow graph and general information about the branching inside
the program there. %TODO: Discuss the files?

After that, in order to obtain possible values for the observed
variables for maximal code coverage, one has to run the tool
\texttt{run\_crest} with the following inputs:
\begin{itemize}
  \item The executable file that was compiled by \texttt{crestc}
  \item A number of maximal iterations through the control flow graph
    we want to allow (i.e. a limitation to the paths we
    want to consider. Otherwise the program might run too long)
  \item A strategy \textsc{CREST} should use to traverse the control
    flow graph. Possible options here are in the set
\begin{center}
$\{$\texttt{dfs}, \texttt{cfg}, \texttt{random},
    \texttt{uniform\_random}, \texttt{random\_input}$\}$
\end{center}
\end{itemize}
For details on the respective search strategies consider
\cite{CREST}.

An example of for this would be:
\begin{verbatim}
$ ../bin/run_crest ./hello 10 -dfs
\end{verbatim}

After that, in the same folder some new files do appear. One class of
files have a name of the form \texttt{input}${}^*$, where one can find possible input
variables even if one has not added a \texttt{printf} line as in the
code above (Line 17). Another file is called \texttt{coverage} and contains the
nodes in the control flow graph indicated by numbers that are
covered. Additionally, one can find a file called
\texttt{szd\_execution}, where the intermediate symbolic formulas that
appeared during the execution of \texttt{run\_crest} can be found.

\begin{remark}
  The \texttt{input} files are only added by default in
  \textsc{CREST-Z3}, but not in the original \textsc{CREST}. In order
  to instrument \textsc{CREST} to do the same, one can follow the
  instructions given here: \url{https://code.google.com/p/crest/wiki/FAQ}.
\end{remark}

For the code given in Example \ref{ex:codeForDemo}, one of the \texttt{input}-files has
the following content:
\begin{verbatim}
-1
1
1
1409925863
\end{verbatim}

That means, that $x :=-1, y:=1, z:=1, w:=1409925863$ would be possible
inputs to reach the code lines 17 and 18.

\begin{remark}
That $w$ has such a large
value is due to the fact that it does not matter what we put for $w$
as input, as it is redefined in line 15 dependent on $x,y$ and
$z$. Therefore, it did not play a role in any further symbolic
evaluation and the standard test value that is chosen randomly for the
first run is kept.
\end{remark}

\subsection{Limitations of \textsc{CREST} and Possible Workarounds}

We have created several small test cases to check what CREST can and
what it cannot -- or just partially -- do. In this section, we will only discuss
limitations that are independent from the solving technique used. The
theoretical and practical limitations of the solving routine is subject of section \ref{sctn:Z3}.

\subsubsection{Inability to handle the unary negative operator?}
During the course of our evaluation of CREST, we discovered that it is unable to handle the negative unary operator. For instance, the following code sample was unable to be solved by CREST:

\begin{example}
\label{ex:codeForDemo}
\begin{verbatim}

if ( x*x*x == -8){
    printf("GOAL %d\n", x);
    return 1;
}
\end{verbatim}
\end{example}
\subsubsection{Interprocedural Analysis Possible... Or Not?}

We discovered a reasonable flaw concerning interprocedural analysis.

Consider Example \ref{ex:codeForDemo} again, and assume we replace
line 14 by
\begin{verbatim}
if (f(x,y,z))
\end{verbatim}
where \texttt{f} is the following function:
\begin{verbatim}
f(int x, int y, int z){return x*y+z==0;}
\end{verbatim}

Using this instruction, \textsc{CREST} fails to produce possible
outputs to enter the branches induced by the modified \texttt{if}
statement.

However, let us replace line 14 is instead by

\begin{verbatim}
if (f_2(x,y,z)==0)
\end{verbatim}

where \texttt{f\_2} is the function
\begin{verbatim}
f_2(int x, int y, int z){return x*y+z;}
\end{verbatim}

Then everything works well and \textsc{CREST} is able to state and
solve the necessary equations to branch into the body of that \texttt{if}-statement.

But what went wrong? Studying the file \texttt{szd\_execution}, it
appears that it failed to produce the equations that need to be
solved. We assume that this is due to the fact that during the
analysis process, \textsc{CREST} is not able to set conditions under
which conditions the boolean expression \texttt{x*y+z == 0} itself makes the
\texttt{if} statement evaluate to be true. If it is directly inside
the \texttt{if}-statement, it is clear to \textsc{CREST} how to
evaluate it. But in the case of \texttt{f}, it fails to reason that
\texttt{f} evaluates to
\texttt{1}, the \textsc{C} equivalence to \texttt{true}, exactly when \texttt{x*y+z == 0}.
This can be seen as an issue of the analysis process, and we will post
it right after this project is handed in.

\subsubsection{Double resp. Float Variables}
\label{sbsbsctn:dblrespfloat}

We mentioned above the data types supported by \textsc{CREST}. What is
missing are datatypes like \texttt{float} or \texttt{double}. Both
\textsc{Z3} and \textsc{YICES} (for the original \textsc{CREST}) are
able to handle that.

In fact, as we will see in Section \ref{sctn:Experiments}, for a large set
of implementations where nonlinear equations play a role inside \texttt{if}
statements have floating point variables that determine the
evaluation.

For the original \textsc{CREST}, there exists a patch to extend its
functionality to be able to handle also floating point variables
(\url{https://code.google.com/p/crest/}, Issue \#15). That
patch can unfortunately not analogously be applied to
\textsc{CREST-Z3}. We encountered that for this instrumentation we
would need to refactor large parts of the core of \textsc{CREST-Z3}
and this would go beyond the scope of our project.

\subsubsection{Arrays}

Even though both \textsc{Z3} as well as \textsc{YICES} are capable of
handling array types, \textsc{CREST} does not support that as an
observable type. This can be seen as a flaw, even though there is a
workaround to this: In the original \textsc{CREST} paper
(\cite{CREST}), the authors were testing their software on the open
source program \textsc{grep} with a very high coverage rate (60\% of
the estimated coverable branches).

In fact, one variable they were observing in the project was \texttt{keys}, which is in fact an array. In order to
instrument \textsc{CREST} to do that, they put every entry of the
array into the scope of \textsc{CREST} in the following way:

\begin{verbatim}
[...]
keys = argv[optind++];
  keycc = strlen(keys);
  for(iii=0; iii<keycc;iii++){
    CREST_char(tmp1);
    keys[iii]=tmp1;
  }
  printf("%s\n",keys);
[...]
\end{verbatim}

This means, that \textsc{CREST} adds in every iteration of the
\texttt{for}-loop \texttt{tmp1} as a new variable in. From that moment on, it
knows that keys at certain position store an observed value and then
it can start performing evaluations based on that.

\subsubsection{No Automatic Instrumentation}

For \textsc{CREST}, we need to manually instrument code in order to
clarify which variables it should observe. Depending on the size of
the project, this can be a very long task.  Furthermore, it requires
the program to be executable to work, i.e. one cannot utilize it for
pure in-between test generation for units, but has either to run it once
the project reached the executable state, or one has to write in-between executable routines for the units. Both solutions are not
optimal in general.

%TODO: Our software work

%Here: Software architecture of CREST ?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{\textsc{Z3} And the Problem of Solving Nonlinear Equations}
\label{sctn:Z3}

This section is dedicated especially to \textsc{Z3} and some theory
around solving nonlinear equations.

\subsection{Introduction to Z3}
The tool \textsc{Z3} \cite{de2008z3}  is developed by researchers from \textsc{Microsoft} to decide -- if
possible -- ``Satisfiability modulo theories'' (abbreviated SMT)
problems. These problems are given in first order logic and can be
seen as an extension to the satisfiability problem in predicate logic
(SAT) by introducing datatypes like numbers and their respective
operations. A standard to represent those formulas in a automatically
readable form was developed in the \textsc{SMT-LIB} project  \cite{barrett2010smt}.
The developers of \textsc{Z3} are using this standard as their
internal representation.

We will refrain from providing a detailed description of SMT problems
and their representation as this would exceed the scope of this
report. But the following example will present the basic structure of
those problems.

\begin{example}
  Given the variables $x,y,z$, which we consider to
  be integer numbers. An SMT solver could answer the question whether
  a solution for $x,y$ and $z$ does exist given the following
  constraints:
  \begin{enumerate}
    \item $x \neq y$
    \item $xy+x^2y=z$
    \item $|z|<10$.
  \end{enumerate}
  The solver would either state that he cannot solve this problem, or
  no solution does exist (provable), or it would provide values for
  $x,y$ and $z$ satisfying the given conditions.
\end{example}

\textsc{Z3} can be included as a library to C/++ source code and one
can call the theorem prover from there. This is very handy as one does
not have to parse an input to a tool and parse the output back, but
just can call the respective functions inside his/her own functions.

The source code of \textsc{Z3} was recently (September 2012) published
by Microsoft (\url{http://z3.codeplex.com/}), so we could examine the
techniques the developers used to handle the nonlinear equations we
are looking for inside their code. We will go into more detail on that
after we discussed some theory behind nonlinear equations.

\subsection{Theoretical Limitations}

There are some theoretical limitations given considering the problem
of solving nonlinear equations.

Given the following scenario: consider integer variables $x_1, \ldots,
x_n, n \in \NN$, and a boolean expression inside an if statement that
evaluates to true if and only if a polynomial given in those variables
is zero for some choice of $x_1, \ldots, x_n$. Finding a solution for
the $x_i$ is the so called Hilbert's 10th problem
\cite{davis1984hilbert}, which was proven to be undecidable
\cite{matiyasevich1970enumerable}.

Nonetheless, one can always try to find solutions and cancel the
computations after a certain amount of time.

Given a set of polynomial equations, the status quo to find solutions
is to calculate as a first step a so called Gr\"obner basis of this system (originated
in \cite{buchberger1970algorithmisches}). This can be seen as a
simplification of the system, which leads in the case of the existence
of only finitely many solutions directly to the solutions. Inside the
source code of \textsc{Z3} we could also find an implementation an
algorithm to calculate those bases.

But there is one problem to this approach. Calculating a Gr\"obner
basis has double exponential complexity, independent from the choice
of the algorithm to compute it (\cite{mayr1982complexity}). Therefore,
computations can take a long time and the output may be the most
simple one, but is still hard to utilize for finding the
solutions. The next subsection will provide an example to illustrate
this fact.

Finding solutions to nonlinear equations is also heavily studied in current
research. Almost every computer algebra system provides a
functionality to solve systems of equations, but there are still
plenty of examples where those solvers do fail. Thus one is also
limited by the possibilities current research provides.

\subsection{Practically Hard Problems}

In order to illustrate where one reaches those limitations, we
considered the following code:

\begin{verbatim}
int main(int argc, char *argv[])
{
  int w;
  int x;
  int y;
  int z;
  if (x*x*y*y*y*z*z == 2700){
    if (x*x*y*w + y*y*w*w == 525){
      if ( x * y*w+y*y*y*w*w==1365){
        printf("GOAL %d %d %d %d\n", x, y, z, w);
          return 1;
        }
     }
  }
  return 0;
}
\end{verbatim}

In order to cover all branches, one could use as input $(x,y,z,w) :=
(2,3,5,7)$. \textsc{Z3} is not able to solve it. We stopped the
calculation after a couple of hours.

Let us study the reason why it fails. \textsc{Z3} will try to compute
a Gr\"obner basis of the ideal generated by
\begin{eqnarray*}
  x^2y^3z^2 - 2700, \quad x^2yw + y^2w^2 - 525, \quad xyw + y^3w^2,
\end{eqnarray*}
and based on that result, it will try to solve the equation. As said,
solving for integer values is in general undecidable.

Let us look at the Gr\"obner basis for this system, which we
calculated using the computer algebra system \textsc{Singular}
\cite{Singular:2012}. The output is a polynomial system that fits into
a file of the size of 283KB. We will give a short snapshot of one
element in the output for the sake of visualization:

\begin{verbatim}
6755988021120000yw31-165994625678918400000yw30
+1737133233041462256000000yw29
-10103309530871289445440000000yw28
+35744012480436414061798800000000yw27
-79140476520758021570218836000000000yw26
+108725930332567845122270489310000000000yw25
-88760995051809423012610038134400000000000yw24
+39085314130645312603256453079810000000000000yw23
-7116024938996671115986413518424570000000000000yw22
+[...]
\end{verbatim}

\textsc{Singular} is specialized in performing those computations, and
it took several minutes to compute this Gr\"obner basis. There are
several factors that play a role how fast an algorithm computes this
Gr\"obner basis. One of them is how ``smart'' it is implemented. This
computation can take either minutes or hours, depending on the implementation.

Of course, one can also try to solve those equation using
state-of-the-art computer algebra systems. We observed that those will
not provide the easy solution that we know about this system.

The computer algebra system \textsc{Maple} (\cite{Maple}) e.g. outputs the following:
\begin{verbatim}
{w = w,
x = RootOf(13*w*_Z^6-5*w*_Z^5+13*w^2*_Z^3+(-5*w^2+20475*w)
    *_Z^2-5250*w*_Z-1378125+17745*w^2),
y = -(13*RootOf(13*w*_Z^6-5*w*_Z^5+13*w^2*_Z^3
    +(-5*w^2+20475*w)*_Z^2-5250*w*_Z-1378125+17745*w^2)^2*w[...],
z = 338*RootOf(-15138703125*w^6+61992127968750*w^5
    -12932841796875*w^4-4814544287109375*w^3[...]}
\end{verbatim}

This means that \textsc{Maple} recognizes that the value of $w$ can be
chosen arbitrarily and that the solution solely depends on the values
of $x,y$ and $z$. Furthermore does the solution of \textsc{Maple}
depend on algebraic extensions of the ground field (usually chosen to
be $\QQ$).

The computer algebra system \textsc{Sage} (\cite{sage}), which utilizes
\textsc{Maxima} (\cite{maxima}) for solving such equations, failed to
output any solution.

The last computer algebra system that we tested for those purposes was
\textsc{Mathematica} \cite{wolfram1999mathematica} in the context of
\textsc{Wolfram Alpha}\\ (\url{http://www.wolframalpha.com}). It found
several solutions, but not one with integer values. One solution was
for example:
\begin{verbatim}
w<-(25 sqrt(21))/13 and 
x = Root[13 #1^6 w-5 #1^5 w+13 #1^3 w^2+#1^2 (20475 w-5 w^2)-5250 #1
    w+17745 w^2-1378125&, 1]
and y = 1/2 (sqrt((x^4+2100)/w^2)-x^2/w)
and z = -30 sqrt(3) sqrt(1/(x^2 y^3))
\end{verbatim}

As a conclusion, one can see that deriving an integer solution using
those helps from outside appears to be a very hard task.

\subsection{Alternatives}

\textsc{Z3} is of course not the only \textsc{SMT}-solver that is
available, yet it belongs to the group of the most powerful
ones. Other tools that are capable of solving complex SMTs and that use the
same input as \textsc{Z3} are
\begin{itemize}
  \item \textsc{Alt-Ergo} (\cite{bobotalt}) and
  \item \textsc{CVC4} (\cite{barrett2011cvc4}).
\end{itemize}

In the original \textsc{CREST} project, \textsc{YICES} (\cite{dutertre2006yices}) was used for
solving. It was not capable of nonlinear constraints, but accepted
input in the SMT-LIB standard. Therefore, replacing the SMT-solver in
the \textsc{CREST} project took only the instrumentation effort, which
can also be done similarly with the tools above. This would lead to an
interesting comparison between those tools regarding the branches in
code they are able to resolve.

Another approach that is in our opinion much more preferable would be
to utilize computer algebra systems as the ones mentioned in the last subsection, which in general contain the
implementations of the latest research techniques to solve equations
of all kinds. There is of course more instrumentation to be done in
order to get them to work within the \textsc{CREST} context, but the
extra effort will be paid back by lesser calculation times plus more
robust results.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Experiments And Case Study}
\label{sctn:Experiments}

In this section, we will discuss some experiments on existing software
projects done with
\textsc{CREST}.

We will start by summarizing evaluations done in \cite{CREST} and
\cite{CRESTZ3}.

After that, we will discuss project types where evaluations of
nonlinear equations are likely to be found in \textsc{C/++} programs, and how far spread the use
of nonlinear equations within boolean expressions is.

We will conclude this section by evaluating pieces of code we found
interesting in the context of this project.

\subsection{Summary of Former Evaluations}

The authors of \cite{CREST} has tested the original program on three
different source codes:

\begin{itemize}
  \item \textsc{Vim} (\cite{oualline2001vi}), $\sim 150,000$loc
  \item \textsc{Grep} (\url{http://www.gnu.org/software/grep/}), $\sim
    15,000$loc
  \item \textsc{Replace} (\cite{harrold2010siemens}), $\sim 600$loc
\end{itemize}

They were able to cover over 90\% of \textsc{Replace} within some
minutes. Around 60\% of the branches in \textsc{Grep} were covered
within a couple of minutes, where one could partly make improvements
using different search strategies. For \textsc{Vim}, they only instructed \textsc{CREST} to analyze some modes of the editor, with a
sample input. Within 2-3 hours they were able to cover up to one third
of all branches that were reachable.

In the paper about \textsc{CREST-Z3} (\cite{CRESTZ3}), one can only
find simple proof of concepts that it extends the classical
\textsc{CREST}. A large test on real world programs has not been made.

\subsection{How Often do Nonlinear Equations Appear in Real World
  programs}

\subsubsection{Ad Real World Programs According to the Limitations.}
First, we were searching for \textsc{if} statements in programs that
contain nonlinear expressions in the supported types. Our search was
not fruitful, and only brought up a few examples that contained the
desired property.

Considering the \textsc{CRYPTO++} library
(\url{http://www.cryptopp.com/}), we could only find a few, fairly
simple tests of the following format:

\begin{verbatim}
<<rsa.cpp>>
[...]
[168] Integer a = modn.Exponentiate(i, r);
[169] if (a == 1)
[170]     continue;
[...]
\end{verbatim}

Those examples are not very hard to solve.

Looking at the source code of the computer algebra systems \textsc{Singular} (\cite{Singular:2012})
and \textsc{GAP} (\cite{GAP4}), where we assumed to find examples,
revealed that there is no occurrence of boolean expressions consisting
of nonlinear expressions to be
found in the code.

Our conclusion is that nonlinear constraints with the standard
supported datatypes in \textsc{CREST} are very rare to be found in
real life \textsc{C} code.

\subsubsection{Ad Real World Programs outside the Limitations.}

If we assume that floating point numbers would also be supported, the
range of real world programs that contain boolean expression based on
nonlinear equations is much higher.

The first type of programs where those types of equations do appear
are coming from the field of computer graphics. In the technique called ``ray
tracing'' (\cite{glassner1989introduction}) for example, they are very common. The following code snippet serves as an example in what way one finds them there (taken from \url{http://www.codermind.com/articles/Raytracer-in-C++-Part-I-First-rays.html}):
\begin{verbatim}
[...]
[1] double B = r.dir * dist;
[2] double D = B*B - dist * dist + s.size * s.size; 
[3] if (D < 0.0f) 
[4]     return false; 
[5] double t0 = B - sqrt(D); 
[6] double t1 = B + sqrt(D);
[7] bool retvalue = false;  
[9] if ((t0 > 0.1f) && (t0 < t)) 
[...]
\end{verbatim}

In line 2, the variable \texttt{D} is calculated using a nonlinear polynomial
formula. In the next line it is checked whether the result is smaller
than zero or not.
This code snippet furthermore shows an inconvenience we would obtain
if we would allow floating point numbers, namely the square root use
in line 5 and 6 and the boolean expression based on it in line 9. There are publications on ways to define square root and other
floating point typical operations that extend \textsc{SMT-LIB},
e.g. \cite{rummer2010smt}, and the basic preliminaries are included in
the \textsc{SMT-LIB} version 2.0. Nonetheless, we could not find the
full support of the arithmetic in the solvers. If one would extend
\textsc{CREST-Z3} to also handle floating point numbers, this problem
should also be taken into consideration.

Another area where we found boolean expressions based on nonlinear equations in floating point numbers were algorithms coming from finance. There is an interesting collection of \textsc{C++} programs in \cite{odegaard2003financial}. The way they appear there mostly is in converging constraints and in early termination of a program if a certain formula is fulfilled. The same holds for algorithms coming from numerics; consider for example the project \textsc{LAMMPS} (Mollecular Dynamics Simulator, \cite{plimpton2007lammps}).

Summa summarum one can say that considering nonlinear constraints, in practice it is only reasonable to additionally consider them if also floating point numbers are supported. For the supported datatypes, one rarely finds code where those play a significant, non-trivial role.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion and Future Work}
\label{sctn:Conclusion}

%Here: Extension to other programming languages? Or even Computer algebra systems?
%         Feasible for real world, as conditions do not get very complicated in general
%         Good for testing software that implements formulas or approximations.
%         Extending it to more general data-types?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliography{report}

\end{document}
