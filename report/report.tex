\documentclass[oribibl]{llncs}
 
\usepackage{amssymb} % AMS Fonts
\usepackage{amsmath} % AMSLaTeX
\usepackage{url}

\newcommand{\ZZ}{{\mathbb{Z}}}
\newcommand{\QQ}{{\mathbb{Q}}}
\newcommand{\RR}{{\mathbb{R}}}
\newcommand{\CC}{{\mathbb{C}}}
\newcommand{\NN}{{\mathbb{N}}}
\renewcommand{\H}{{\mathcal{H}}}
\renewcommand{\L}{{\mathcal{L}}}
\newcommand{\F}{{\mathsf{F}}}
\newcommand{\bigO}{{\mathsf{O}}}
\newcommand{\R}{{\mathsf{R}}}
\newcommand{\Fp}{{\mathbb{F}_p}}
\newcommand{\Fq}{{\mathbb{F}_q}}
\newcommand{\Fqd}{{\mathbb{F}_{q^d}}}
\newcommand{\Fqe}{{\mathbb{F}_{q^e}}}
\newcommand{\Fz}{{\F[z]}}
\newcommand{\Fzf}{{\Fz /(f)}}
\newcommand{\Fzfe}{{\Fz /(f^e)}}
\newcommand{\Rn}{{\R^{n \times 1}}}
\newcommand{\Rnn}{{\R^{n \times n}}}
\newcommand{\Fden}{{\F^{den \times 1}}}
\newcommand{\Fdenden}{{\F^{den \times den}}}
\newcommand{\ZZp}{{\ZZ_p}}
\newcommand{\ZZpe}{{\ZZ_{p^e}}}
\newcommand{\nxn}{{n\times n}}
\newcommand{\calI}{{\mathcal I}}

\newcommand{\FD}{{\F[\partial;\sigma,\delta]}}
\newcommand{\D}{{\partial}}
\newcommand{\shift}{{\mathcal{S}}}
\newcommand{\diff}{{\lower3pt\hbox{\large$'$}}}
\renewcommand{\k}{{\mathsf{k}}}
\newcommand{\lclm}{{\mbox{\upshape lclm}}}
\newcommand{\lcrm}{{\mbox{\upshape lcrm}}}
\newcommand{\gcld}{{\mbox{\upshape gcld}}}
\newcommand{\gcrd}{{\mbox{\upshape GCRD}}}



\newcommand{\smallskipback}{\vspace{-\smallskipamount}}
\newcommand{\medskipback}{\vspace{-\medskipamount}}
\newcommand{\bigskipback}{\vspace{-\bigskipamount}}



%\reversemarginpar
\makeatletter
\@twosidefalse
\makeatother
%\renewcommand*{\marginfont}{\color{red}\bf}
%\newcommand{\TODO}[1]{\marginnote[#1]{}}

\bibliographystyle{alpha}

\begin{document}

\title{\textsc{CREST-Z3} - Automated Test Generation Capable of Nonlinear Constraints\\[12pt]
Project for CS847}

\author{X. Lan, M. Wexler, A. Heinle}

\institute{University of Waterloo, David R. Cheriton School of Computer Science}

\maketitle

\begin{abstract}
  In this project we will explore \textsc{CREST-Z3} \cite{CRESTZ3}, an automated test case generator for C-programs. It is an extension of the tool \textsc{CREST} \cite{CREST} capable of solving nonlinear constraints in the process of generating tests. We will discuss the capabilities and the practical, as well as the theoretical limitations of this tool.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

In the beginning of the course, there was a presentation given on the
paper \cite{godefroid2005dart}. The authors of this paper presented an
automated way of generating test sets for given programs written in
the programming language \textsc{C}. The main principle of that tool
appears in the literature as \textbf{Concolic Testing} (this terminology appeared
for the first time in the paper \cite{sen2005cute}).

Informally speaking, concolic testing refers the concrete
execution of the program given either random or specifically chosen
values for the variables. During this execution, one collects symbolic
conditions on the
variables in order to reach code lines whenever a branch occurs
(e.g. induced by an \texttt{if}-statement). Those conditions are fed
to a theorem prover in order to solve for possible variable values to
enter each branch. With that, people are trying to generate test sets
that satisfy the best coverage of the code -- in terms of nodes in the
control flow graph -- as possible.

\textsc{CREST}, in its original version, used a theorem prover called
\textsc{YICES} (\cite{dutertre2006yices}) for the part of solving
conditions to enter a branch. It is a powerful tool, yet it has a
significant weakness: It can only deal with linear equations. This is
a strong restriction, as for example an equation like
$$x^2 = 10 \mod 47$$
for $x \in \ZZ$ could not be resolved.
Also in other concolic testing tools like \textsc{CUTE}
(\cite{sen2005cute}), \textsc{DART},
\textsc{EXE} (\cite{cadar2008exe}) and \textsc{PathCrawler}
(\cite{williams2005pathcrawler}), only linear equations could be resolved.

This is the case for a good reason, as we will see in a succeeding
section where we will discuss computational limitations we have
considering nonlinear equations.

Nevertheless, for the nonlinear case, in the project \textsc{CREST-Z3}, the theorem prover was replaced
by \textsc{Microsoft}s theorem prover \textsc{Z3}
(\cite{de2008z3}), which can handle a broader range of equation types
including nonlinear equations. \textsc{CREST-Z3}, its architecture and
its practicality will be the subject of this paper.

The paper is organized as follows. Section \ref{sctn:CRESTZ3} is
dedicated to \textsc{CREST}(-\textsc{Z3}. We will see how one can use
this tool, specialities about its architecture, and some limitations
that we found.

In section \ref{sctn:Z3}, we will examine those limitations a little
bit closer from a theoretical point of view. A general overview of
\textsc{Z3} will also be provided.

Section \ref{sctn:Experiments} contains experiments we have done with
\textsc{CREST-Z3}. Furthermore, we were examining types of open source projects
where nonlinear equations do play a role in the branching conditions
of the code.

The last section draws a conclusion of our work. Furthermore, we will
provide possible ways how one can improve/extend the work to make it
either faster or more practically useful.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\textsc{CREST}(-\textsc{Z3})}
\label{sctn:CRESTZ3}
%Here: How to use CREST
%         Software architecture of CREST
%         Limitations of CREST
%         Examples

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{\textsc{Z3} And the Problem of Solving Nonlinear Equations}
\label{sctn:Z3}

\subsection{Introduction to Z3}
The tool \textsc{Z3} \cite{de2008z3}  is developed by researchers from \textsc{Microsoft} to decide -- if
possible -- ``Satisfiability modulo theories'' (abbreviated SMT)
problems. These problems are given in first order logic and can be
seen as an extension to the satisfiability problem in predicate logic
(SAT) by introducing datatypes like numbers and their respective
operations. A standard to represent those formulas in a automatically
readable form was developed in the \textsc{SMT-LIB} project  \cite{barrett2010smt}.
The developers of \textsc{Z3} are using this standard as their
internal representation.

We will refrain from providing a detailed description of SMT problems
and their representation as this would exceed the scope of this
report. But the following example will present the basic structure of
those problems.

\begin{example}
  Given the variables $x,y,z$, which we consider to
  be integer numbers. An SMT solver could answer the question whether
  a solution for $x,y$ and $z$ does exist given the following
  constraints:
  \begin{enumerate}
    \item $x \neq y$
    \item $xy+x^2y=z$
    \item $|z|<10$.
  \end{enumerate}
  The solver would either state that he cannot solve this problem, or
  no solution does exist (provable), or it would provide values for
  $x,y$ and $z$ satisfying the given conditions.
\end{example}

\textsc{Z3} can be included as a library to C/++ source code and one
can call the theorem prover from there. This is very handy as one does
not have to parse an input to a tool and parse the output back, but
just can call the respective functions inside his/her own functions.

The source code of \textsc{Z3} was recently (September 2012) published
by Microsoft (\url{http://z3.codeplex.com/}), so we could examine the
techniques the developers used to handle the nonlinear equations we
are looking for inside their code. We will go into more detail on that
after we discussed some theory behind nonlinear equations.

\subsection{Theoretical Limitations}

There are some theoretical limitations given considering the problem
of solving nonlinear equations.

Given the following scenario: consider integer variables $x_1, \ldots,
x_n, n \in \NN$, and a boolean expression inside an if statement that
evaluates to true if and only if a polynomial given in those variables
is zero for some choice of $x_1, \ldots, x_n$. Finding a solution for
the $x_i$ is the so called Hilbert's 10th problem
\cite{davis1984hilbert}, which was proven to be undecidable
\cite{matiyasevich1970enumerable}.

Nonetheless, one can always try to find solutions and cancel the
computations after a certain amount of time.

Given a set of polynomial equations, the status quo to find solutions
is to calculate as a first step a so called Gr\"obner basis of this system (originated
in \cite{buchberger1970algorithmisches}). This can be seen as a
simplification of the system, which leads in the case of the existence
of only finitely many solutions directly to the solutions. Inside the
source code of \textsc{Z3} we could also find an implementation an
algorithm to calculate those bases.

But there is one problem to this approach. Calculating a Gr\"obner
basis has double exponential complexity, independent from the choice
of the algorithm to compute it (\cite{mayr1982complexity}). Therefore,
computations can take a long time and the output may be the most
simple one, but is still hard to utilize for finding the
solutions. The next subsection will provide an example to illustrate
this fact.

Finding solutions to nonlinear equations is also heavily studied in current
research. Almost every computer algebra system provides a
functionality to solve systems of equations, but there are still
plenty of examples where those solvers do fail. Thus one is also
limited by the possibilities current research provides.

\subsection{Practically Hard Problems}

In order to illustrate where one reaches those limitations, we
considered the following code:

\begin{verbatim}
int main(int argc, char *argv[])
{
  int w;
  int x;
  int y;
  int z;
  if (x*x*y*y*y*z*z == 2700){
    if (x*x*y*w + y*y*w*w == 525){
      if ( x * y*w+y*y*y*w*w==1365){
        printf("GOAL %d %d %d %d\n", x, y, z, w);
          return 1;
        }
     }
  }
  return 0;
}
\end{verbatim}

In order to cover all branches, one could use as input $(x,y,z,w) :=
(2,3,5,7)$. \textsc{Z3} is not able to solve it. We stopped the
calculation after a couple of hours.

Let us study the reason why it fails. \textsc{Z3} will try to compute
a Gr\"obner basis of the ideal generated by
\begin{eqnarray*}
  x^2y^3z^2 - 2700, \quad x^2yw + y^2w^2 - 525, \quad xyw + y^3w^2,
\end{eqnarray*}
and based on that result, it will try to solve the equation. As said,
solving for integer values is in general undecidable.

Let us look at the Gr\"obner basis for this system, which we
calculated using the computer algebra system \textsc{Singular}
\cite{Singular:2012}. The output is a polynomial system that fits into
a file of the size of 283KB. We will give a short snapshot of one
element in the output for the sake of visualization:

\begin{verbatim}
6755988021120000yw31-165994625678918400000yw30
+1737133233041462256000000yw29
-10103309530871289445440000000yw28
+35744012480436414061798800000000yw27
-79140476520758021570218836000000000yw26
+108725930332567845122270489310000000000yw25
-88760995051809423012610038134400000000000yw24
+39085314130645312603256453079810000000000000yw23
-7116024938996671115986413518424570000000000000yw22
+[...]
\end{verbatim}

\textsc{Singular} is specialized in performing those computations, and
it took several minutes to compute this Gr\"obner basis. There are
several factors that play a role how fast an algorithm computes this
Gr\"obner basis. One of them is how ``smart'' it is implemented. This
computation can take either minutes or hours, depending on the implementation.

Of course, one can also try to solve those equation using
state-of-the-art computer algebra systems. We observed that those will
not provide the easy solution that we know about this system.

The computer algebra system \textsc{Maple} (\cite{Maple}) e.g. outputs the following:
\begin{verbatim}
{w = w,
x = RootOf(13*w*_Z^6-5*w*_Z^5+13*w^2*_Z^3+(-5*w^2+20475*w)
    *_Z^2-5250*w*_Z-1378125+17745*w^2),
y = -(13*RootOf(13*w*_Z^6-5*w*_Z^5+13*w^2*_Z^3
    +(-5*w^2+20475*w)*_Z^2-5250*w*_Z-1378125+17745*w^2)^2*w[...],
z = 338*RootOf(-15138703125*w^6+61992127968750*w^5
    -12932841796875*w^4-4814544287109375*w^3[...]}
\end{verbatim}

This means that \textsc{Maple} recognizes that the value of $w$ can be
chosen arbitrarily and that the solution solely depends on the values
of $x,y$ and $z$. Furthermore does the solution of \textsc{Maple}
depend on algebraic extensions of the ground field (usually chosen to
be $\QQ$).

The computer algebra system \textsc{Sage} (\cite{sage}), which utilizes
\textsc{Maxima} (\cite{maxima}) for solving such equations, failed to
output any solution.

The last computer algebra system that we tested for those purposes was
\textsc{Mathematica} \cite{wolfram1999mathematica} in the context of
\textsc{Wolfram Alpha}\\ (\url{http://www.wolframalpha.com}). It found
several solutions, but not one with integer values. One solution was
for example:
\begin{verbatim}
w<-(25 sqrt(21))/13 and 
x = Root[13 #1^6 w-5 #1^5 w+13 #1^3 w^2+#1^2 (20475 w-5 w^2)-5250 #1
    w+17745 w^2-1378125&, 1]
and y = 1/2 (sqrt((x^4+2100)/w^2)-x^2/w)
and z = -30 sqrt(3) sqrt(1/(x^2 y^3))
\end{verbatim}

As a conclusion, one can see that deriving an integer solution using
those helps from outside appears to be a very hard task.

\subsection{Alternatives}

\textsc{Z3} is of course not the only \textsc{SMT}-solver that is
available, yet it belongs to the group of the most powerful
ones. Other tools that are capable of solving complex SMTs and that use the
same input as \textsc{Z3} are
\begin{itemize}
  \item \textsc{Alt-Ergo} (\cite{bobotalt}) and
  \item \textsc{CVC4} (\cite{barrett2011cvc4}).
\end{itemize}

In the original \textsc{CREST} project, \textsc{YICES} (\cite{dutertre2006yices}) was used for
solving. It was not capable of nonlinear constraints, but accepted
input in the SMT-LIB standard. Therefore, replacing the SMT-solver in
the \textsc{CREST} project took only the instrumentation effort, which
can also be done similarly with the tools above. This would lead to an
interesting comparison between those tools regarding the branches in
code they are able to resolve.

Another approach that is in our opinion much more preferable would be
to utilize computer algebra systems as the ones mentioned in the last subsection, which in general contain the
implementations of the latest research techniques to solve equations
of all kinds. There is of course more instrumentation to be done in
order to get them to work within the \textsc{CREST} context, but the
extra effort will be paid back by lesser calculation times plus more
robust results.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Experiments And Case Study}
\label{sctn:Experiments}

%Here: Real life C programs (instructed)
%         Outline how often we find really complicated examples in C-Code
%         Feasibility of instructing programs for CREST


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion and Future Work}
\label{sctn:Conclusion}

%Here: Extension to other programming languages? Or even Computer algebra systems?
%         Feasible for real world, as conditions do not get very complicated in general
%         Good for testing software that implements formulas or approximations.
%         Extending it to more general data-types?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliography{report}

\end{document}
